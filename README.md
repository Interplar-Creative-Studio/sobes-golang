
# Задача 1. Enum

В подавляющем большинстве проектов имеются сущности, содержащие строковое поле, которое
жёстко ограничено допустимыми значениями.
Это может быть статус (`pending`, `active`, `inactive`, `blocked`, `draft` и тп),
это может быть какой-нибудь тип авторизации пользователя (`email`, `phone`, `google`,
`telegram`), ну или роль пользователя (`admin`, `moderator`, `customer`, `marketing` и тп),
если конечно роли фиксированы и не создаются из админки.

В таких случаях это жёсткое ограничение обуславливается постоянным использованием проверок
с перебором допустимых значений, чтобы в базу не попало какое-то непонятно лишнее значение
или пустая строка. Одним из способов борьбы с этим выступает использование ограничений
для нужной колонки на уровне базы данных, но это не всегда помогает и по итогу в коде
остаются безымянные строки, а в лучшем случае константы с нужными значениями.

При написании CRUD-операций над сущностями вылезает проблема валидации допустимых значений,
так как приходится составлять слайс из доступных значений и обходить его. В идеале реализуется
отдельная функция, которая занимается как раз валидацией по вхождению в слайс.

Достаточно удобным решением выступает создание логики перечислений (Enum). Это позволяет, к примеру,
вместо `Status string` писать `Status entity_status.Status`, добавлять к этому типу `Status`
различные методы, а также хранить `entity_status.Enum()` функцию, которая предоставляет объект
перечисления, способный проверить валидность переданного в запросе статуса, либо просто получить
`Status` из `string`.

> В рамках данной задачи необходимо реализовать функционал перечислений, который позволит уйти
> от строковых полей и переменных к конкретным типам и упрощению валидации.
> 
> Основа для написания кода лежит в папке `task1`.

# Задача 2. Парсер конфигурации

> Необходимо реализовать парсер конфигурации из yaml. Для примера подготовлены структуры
> `AppConfig` и `DbConfig`.
> В реальности не всегда есть возможность указать в каждой структуре необходимые теги для всех
> видов парсеров (json, xml, yaml, env и тп), поэтому более универсальным подходом будет
> небольшое автоопределение ключа по имени поля.
> 
> В рамках данной задачи нужно реализовать ParseConfig() функцию, которая будет превращать содержимое
> yaml-файла в указанную ей структуру. Причём привязываться конкретно к AppConfig и DbConfig не надо,
> функция должна быть универсальна и уметь собирать любую структуру конфига.

> Подсказка.
> 
> Достаточно обходить поля структуры через рефлексию, определять возможные их ключи для yaml
> и парсить в них значения. К примеру в случае с `DB1` и `DB2` стоит посмотреть на наличие тега yaml.
> Если тег есть, то пробуем достать значение по указанному в нём ключу. Если тега нету, то берём
> поле и достаём значение по имени поля, по имени поля в нижнем или верхнем регистре. Также
> можно конвертировать в `kebab-case`, `snake-case` или `camel-case`
> (для этого есть [библиотека](https://github.com/ettle/strcase)), что тоже повысит гибкость конфига.
> 
> Если значение не найдено, оставляем поле пустым.
> 
> Стандартный парсер из пакета `yaml` тут не подойдёт, но можно распарсить весь конфиг
> в `map[string]any`, а потом уже для каждого поля искать значения по string-ключу.
> Проходить по структуре надо рекурсивно.

> В качестве дополнительного задания можно улучшить парсер так, чтобы он умел при парсинге yaml
> подставлять ENV-переменные (пример в файле task2/config-extra.yaml). Так парсер позволит работать
> с ещё более гибкими конфигами.




